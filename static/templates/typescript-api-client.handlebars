{{#* inline "property"}}
{{#if this.isObject}}
{{#each this.type}}
{{@key}}: {{> property }}
{{/each}}
{{else}}
{{this.type}}
{{/if}}
{{#if this.isArray}}[]{{/if}};
{{/inline}}

{{#each schemas}}
export class {{this.name}} {
  {{#unless this.isRef}}
  {{#with this.properties}}
  {{> property }}
  {{/with}}
  {{/unless}}
}
{{/each}}

{{#each paths}}
{{#each this.endpoints}}
export class {{this.request.className}} {{#if this.request.isRef}}extends {{this.request.properties.type}} {{/if}} {
  {{#unless this.request.isRef}}
  {{#with this.request.properties}}
  {{> property }}
  {{/with}}
  {{/unless}}
  {{#if this.request.parameters}}
  parameters: {
    {{#each this.request.parameters}}
    {{this.key}}: {{#with this.type}}{{> property }}{{/with}}
    {{/each}}
  };
  {{/if}}
}

{{/each}}
{{/each}}

export interface Response {
  description: string;
}

{{#each paths}}
{{#each this.endpoints}}
{{#each this.responses}}
export class {{this.className}} {{#if this.isRef}}extends {{this.properties.type}} {{/if}}implements Response {
  description = '{{this.description}}';
  {{#unless this.isRef}}
  {{#with this.properties}}
  {{> property }}
  {{/with}}
  {{/unless}}
}

{{/each}}
{{/each}}
{{/each}}

{{#each paths}}
{{#each this.endpoints}}
export const {{this.pascal}} = async (req: {{this.request.className}}): Promise<{{#each this.responses}}{{this.className}}{{#unless @last}}|{{/unless}}{{/each}}> => {
  try {
    const res = await fetch();
    const json = await res.json();
    return json as {{this.responses.[0].className}};
  } catch (err) {
    throw new Error("Error");
  }
};
{{/each}}
{{/each}}