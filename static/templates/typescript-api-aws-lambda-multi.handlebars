{{#* inline "property"}}
{{#if this.isObject}}
{{#each this.type}}
{{@key}}{{#unless this.required}}?{{/unless}}: {{> property }}
{{/each}}
{{else if this.isArray ~}}
{{#with this.items}}{{> property ~}}{{/with ~}}[]
{{else~}}
{{~this.typescriptType ~}}
{{/if}}
{{/inline}}

{{#each schemas}}
export class {{this.name}} {
  {{#unless this.isRef}}
  {{#with this.properties}}
  {{> property }}
  {{/with}}
  {{/unless}}
}
{{/each}}

{{#each paths}}
{{#each this.endpoints}}
export class {{this.request.className}} {{#if this.request.isRef}}extends {{this.request.properties.type}} {{/if}} {
  {{#unless this.request.isRef}}
  {{#with this.request.properties}}
  {{> property }}
  {{/with}}
  {{/unless}}
  {{#if this.request.parameters}}
  parameters: {
    {{#each this.request.parameters}}
    {{this.name}}: {{#with this.type}}{{> property }}{{/with}}
    {{/each}}
  };
  {{/if}}
}

{{/each}}
{{/each~}}

export interface Response {
  description: string;
}

{{#each paths}}
{{#each this.endpoints}}
{{#each this.responses}}
export class {{this.className}} {{#if this.isRef}}extends {{this.properties.typescriptType}} {{/if}}implements Response {
  description = '{{this.description}}';
  {{#unless this.isRef}}
  {{#with this.properties}}
  {{> property }}
  {{/with}}
  {{/unless}}
}

{{/each}}
{{/each}}
{{/each~}}

{{#each paths}}
{{#each this.endpoints}}
export const {{this.pascal}} = async (req: {{this.request.className}}): Promise<{{#each this.responses}}{{this.className}}{{#unless @last}}|{{/unless}}{{/each}}> => {

};

{{/each}}
{{/each}}